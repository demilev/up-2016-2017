##Масиви

Масивите се използват за съхраняване на данни, но често е по-полезно да се мисли за масив като съвкупност от променливи от един и същ тип. Специфичен елемент в масив се достъпва чрез индекса.

_Декларация_

Общ вид на декларация : тип име[размер] , където на мястото на тип стои който и да е валиден тип в с++, а размерът е целочислена константа по-голяма от нула.

Примери : 

```c++
	int array[10];
	double array2[150];
```
_Инициализация_

Елементите на масви могат да се инициализират един по един.

Пример : 

```c++
	int array[3];
	array[0]=1;
	array[1]=2;
	array[2]=3;
	array[3]=5; // това не води до грешка!
```

Но също могат и наведнъж.

Примери :

```c++
	int array[3]={1,2,3};  // това е равносилно на int array[]={1,2,3}; 
	int array2[3]={1,2,3,4}; // това води до грешка!
```
_Достъпване на елементите_

Достъпваме елементите на масива чрез индекс. С отделните елементи можем да работи като най-обикновени променливи, т.е да ги събираме, да им присвояваме стойност, да ги въвеждаме от клавиатурата, да ги печатаме, да ги присвояваме на други променливи, да ги използваме в изрази и т.н.

Примери :

```c++
	int array[3]={1,2,3};
	int a=array[1] ;  // стойността на а става 2

	int array[3];
	cin>>array[0];   
	cin>>array[1];   //въвеждане на елементи от клавиатурата
	cin>>array[2];

	int array[3]={1,2,3};
	if( (array[0]+array[1]) >= array[2] )   // пример за използване в израз 
		cout<<array[0]+array[1]+array[2];   // пример за печатане
```
Класическо обхождане на масив става чрез _for_ цикъл.

Класически пример за въвеждане на елементите на масив от клавиатурата :

```c++
	int array[100];
	int size;
	cout<<"Please input the size : ";
	cin>>size;
	//тук може да има проверка дали въведеният size е коректен
	for(int i=0;i<size;i++){
		cout<<"Please input array["<<i<<"] : ";
		cin>>array[i];
	}
```

Класически пример за отпечатване на елементите на масива на екрана :

```c++
	//в този пример приемаме, че масивът вече е създаден 
	//и има size на брой вече съшествуващи елементи	
	
	for(int i=0;i<size;i++){
		cout<<"array["<<i<<"] = "<<array[i];
	}
```
Непозволени неща : 

```c++
	int array[];  // грешно
	
	int n;
	cin>>n;
	int array[n];  // грешно
	
	int array[3]; 
	int array1[4]; 
	int a=array+array1; // грешно

	int array[5];
	cin>>array;   // грешно

	//има и още много :д
```

##Символни низове

Символните низове са просто масиви от char-ове, като голямата разлика с другите масиви е наличието на терминираща нула, която показва края на низа.

Пример:

```c++	
	char array[10];
```
Разлики с "обикновените" масиви :

```c++
	char array[]="Hello world!"

	char array1[100];
	cin>>array1; // позволено за символни низове и препоръчително за използване
				 // проблемът тук е, че ако натиснем space, всичко след това него
				 // няма да се запише в масива
	//въвеждане един по един на елементите чрез цикъл
	char array[100];
	int size;
	cout<<"Please input the size : ";
	cin>>size;
	//тук може да има проверка дали въведеният size е коректен
	for(int i=0;i<size;i++){
		cout<<"Please input array["<<i<<"] : ";
		cin>>array[i];
	}
	array[size]='\0' // НЕ ТРЯБВА ДА СЕ ЗАБРАВЯ ДОБАВЯНЕТО НА ТЕРМИНИРАЩАТА НУЛА
					 // при този подход трябва ръчно да се погрижим
					 // може да експериментирате да видите какво ще стане 
					 // ако я няма

	cout<<array;     // позволен начин на печатане имено заради терминиращата нула
```

_Функции от библиотеката cstring за низове_

```c++
	char array[]="Hello";
	strlen(array)  // размерът на низа

	char array[]="Hello";
	char array1[]="Hello World!";
	strcmp(array,array1) // сравнява лексикографски двата низа и
						 // връща положително число, ако първият
						 // е "по-голям" (т.е по-напред в речника) от втория,
						 // отрицателно число, ако вторият е"по-голям"
						 // от първия и нула, ако са еднакви

	char array[10];
	char array1[]="Hello";
	strcpy(array,array1) // копира съдържанието на втория низ в първия
```

Тези три са най-използвани, но има и още много други, които може да потърсите в интернет.

##Масиви и низове като аргументи на функции

Класически пример за подаване на масив като аргумент на функция :

```c++
	int sumOfElements(int arr[],int size) // подаваме като аргумент на функцията и размерът на масива освен самия него
	{
        int result=0;
        for(int i=0;i<size;i++) // ето защо ни е размерът - за да можем да знаем колко е голям масивът и докъде да го обхождаме
        {
        	result+=arr[i];
        }
        return result;
	}
}
```
Много лоша практика е в тялото на някоя функция да си мислим, че трябва да въвеждаме елементите на масива, освен ако изрично не е казано, че това трябва да прави функцията.

Пример за тази лоша практика :

```c++
	int sumOfElements(int arr[],int size) 
	{
        int result=0;
        for(int i=0;i<size;i++) 
        {
        	cin>>arr[i];  // АБСОЛЮТНО ГРЕШНО! 
        				  // целта на функцията е да приеме вече създаден и инициализиран масив и да каже колко е сумата на елементите му
  						  // няма нужда от въвеждане и печатане на елементите, така ще е и в повечето функции, които ще пишете
        	result+=arr[i];
        }
        return result;
	}
}
```

Когато подаваме символен низ като аргумент на функция няма нужда да слагаме като аргумент на функцията и размера му, защото както вече знаем можем да го намери чрез strlen.

Повече примери за използване на функции с аргументи масиви и низове може да видите в решенията на задачите от [седмица7](https://github.com/geosteffanov/up-2016-2017/tree/master/Week%207/Solutions)

Няколко важни неща и за функциите.

Ключова дума return - когато някъде в кода на функциите ви се стигне до тази дума, то това което се случва е, че чисто и просто функцията приключва и резултатът от нея е това, което стои след ключовата дума return. Отново съветът ни е да разгледате всички решения на задачите с функции и да видите на практика как се случват нещата. Също тако можете да се изтренирате като пишеш свои простички функции и експериментирате с тях.

void функциите не връщат стойност, т.е резултатът от тях не може да бъде присвоен на променлива, защото просто няма такъв резултат. Съответно те и не могат да бъдат печатани чрез cout. Но те от своя страна могат в тялото си да извършват някакъв вид пресмятане.

На променлива може да се присвои резултат от функция(която връща резултат, т.е да не е void). Чрез cout може да се отпечата на екрана резултат от функция(която връща резултат, т.е да не е void).

