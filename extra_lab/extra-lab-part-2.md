# Допълнително упражнение, Част II

Във втората част на допълнителното упражнение ще създадем простичък интерфейс на динамичен масив. Всяка от задачите ще надгражда интерфейса, затова пишете всичко в един файл.   

### Зад. 5

**_Add me_**

Напишете функция _void add(int*& arr,int& size,int newElement)_ , която добавя към края на масива _arr_ елемента _newElement_ като за целта да се задели (динамично) памет за нов масив с дължина _size_ + 1, да се копират всички предишни елементи на _arr_ + новия елемент в новия масив , да се изчисти паметта, която е ползвал _arr_ и накрая _arr_ да сочи към новосъздадения масив и променливата _size_ да е увеличена с 1.

### Зад. 6

**_Insert me_**

Напишете функция _void insertAt(int*& arr,int& size, int newElement, int index)_ , която е генерализация на предишната. Разликата е, че вмъква новия елемнт на позиция 
_index_. Отново трябва да се заделя памет и да се изчиства старата. 

### Зад. 7

**_Resize me_**

Напише функция _void resize(int*& arr, int& size, int newSize)_ , която трябва да пренасочи _arr_ към нов, динамично създаден масив с размер _newSize_. Максимален брой елементи от стария буфер трябва да бъдат копирани в новия. Ако новият размер е по-голям, да се добавят "свободни" места - нули. Ако е по-малък - да липсват елементите от края.

### Зад. 8

**_Copy me_**

Напишете фунцкия _void copy(int* arrayFrom, int sizeFrom, int*& arrayTo, int& sizeTo)_ , която копира елементите от _arrayFrom_ в _arrayTo_ като предварително зачиства паметта към която сочи _arrayTo_ и след това заделя динамично нова памет. 